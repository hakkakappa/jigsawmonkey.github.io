<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>HTML5 Jigsaw Puzzle</title>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
  }

  canvas {
    background: #222;
    border: 2px solid #fff;
  }
</style>
</head>
<body>
<canvas id="puzzle"></canvas>

<script>
const canvas = document.getElementById('puzzle');
const ctx = canvas.getContext('2d');

const img = new Image();
img.src = 'JIGSAW01.jpg';

const rows = 10;
const cols = 12;

let pieces = [];
let pieceWidth, pieceHeight;
let draggedPiece = null;
let offsetX = 0, offsetY = 0;

function drawPiecePath(width, height, top, right, bottom, left) {
  const tab = Math.min(width, height) / 4;

  ctx.beginPath();
  ctx.moveTo(0, 0);
  
function isPointInPiece(px, py, p) {
  const TAB = Math.min(pieceWidth, pieceHeight) / 4;
  const BLEED = TAB;

  ctx.save();
  ctx.translate(p.x - BLEED, p.y - BLEED);

  drawPiecePath(
    pieceWidth,
    pieceHeight,
    p.top,
    p.right,
    p.bottom,
    p.left
  );

  const hit = ctx.isPointInPath(px, py);
  ctx.restore();

  return hit;
}


  // Top
  if (top !== 0) {
    ctx.lineTo(width / 3, 0);
    ctx.bezierCurveTo(
      width / 3, -top * tab,
      2 * width / 3, -top * tab,
      2 * width / 3, 0
    );
  }
  ctx.lineTo(width, 0);

  // Right
  if (right !== 0) {
    ctx.lineTo(width, height / 3);
    ctx.bezierCurveTo(
      width + right * tab, height / 3,
      width + right * tab, 2 * height / 3,
      width, 2 * height / 3
    );
  }
  ctx.lineTo(width, height);

  // Bottom
  if (bottom !== 0) {
    ctx.lineTo(2 * width / 3, height);
    ctx.bezierCurveTo(
      2 * width / 3, height + bottom * tab,
      width / 3, height + bottom * tab,
      width / 3, height
    );
  }
  ctx.lineTo(0, height);

  // Left
  if (left !== 0) {
    ctx.lineTo(0, 2 * height / 3);
    ctx.bezierCurveTo(
      -left * tab, 2 * height / 3,
      -left * tab, height / 3,
      0, height / 3
    );
  }

  ctx.closePath();
}

img.onload = () => {
  canvas.width = img.width;
  canvas.height = img.height;

  pieceWidth = canvas.width / cols;
  pieceHeight = canvas.height / rows;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const piece = {
        x: Math.random() * (canvas.width - pieceWidth),
        y: Math.random() * (canvas.height - pieceHeight),
        correctX: x * pieceWidth,
        correctY: y * pieceHeight,
        col: x,
        row: y,
        top: y === 0 ? 0 : -pieces[(y - 1) * cols + x].bottom,
        left: x === 0 ? 0 : -pieces[y * cols + (x - 1)].right,
        right: x === cols - 1 ? 0 : Math.random() > 0.5 ? 1 : -1,
        bottom: y === rows - 1 ? 0 : Math.random() > 0.5 ? 1 : -1
      };
      pieces.push(piece);
    }
  }

  draw();
};

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const TAB = Math.min(pieceWidth, pieceHeight) / 4;
  const BLEED = TAB;

  for (const p of pieces) {
    ctx.save();
    ctx.translate(p.x - BLEED, p.y - BLEED);

    // ðŸŸ£ SHADOW (drawn BEFORE clip)
if (!p.isPlaced) {
  ctx.shadowColor = 'rgba(0,0,0,0.6)';
  ctx.shadowBlur = 12;
  ctx.shadowOffsetX = 4;
  ctx.shadowOffsetY = 6;
}



    drawPiecePath(pieceWidth, pieceHeight, p.top, p.right, p.bottom, p.left);
    ctx.fillStyle = '#000'; // invisible fill, shadow only
    ctx.fill();

    // âœ‚ï¸ CLIP SHAPE
    ctx.shadowColor = 'transparent';
    drawPiecePath(pieceWidth, pieceHeight, p.top, p.right, p.bottom, p.left);
    ctx.clip();

    // ðŸ–¼ IMAGE (with bleed)
    ctx.drawImage(
      img,
      p.col * pieceWidth - BLEED,
      p.row * pieceHeight - BLEED,
      pieceWidth + BLEED * 2,
      pieceHeight + BLEED * 2,
      -BLEED,
      -BLEED,
      pieceWidth + BLEED * 2,
      pieceHeight + BLEED * 2
    );

    // âœï¸ OUTLINE
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#fff';
    drawPiecePath(pieceWidth, pieceHeight, p.top, p.right, p.bottom, p.left);
    ctx.stroke();

    ctx.restore();
  }
}




// Mouse controls
canvas.addEventListener('mousedown', e => {
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;

  for (let i = pieces.length - 1; i >= 0; i--) {
    const p = pieces[i];

    if (isPointInPiece(mx, my, p)) {
      draggedPiece = p;
      offsetX = mx - p.x;
      offsetY = my - p.y;

      // Bring to top
      pieces.push(pieces.splice(i, 1)[0]);
      break;
    }
  }
});


canvas.addEventListener('mousemove', e => {
  if (!draggedPiece) return;
  const r = canvas.getBoundingClientRect();
  draggedPiece.x = e.clientX - r.left - offsetX;
  draggedPiece.y = e.clientY - r.top - offsetY;
  draw();
});

canvas.addEventListener('mouseup', () => {
  if (!draggedPiece) return;

  if (
    Math.abs(draggedPiece.x - draggedPiece.correctX) < pieceWidth / 3 &&
    Math.abs(draggedPiece.y - draggedPiece.correctY) < pieceHeight / 3
  ) {
    draggedPiece.x = draggedPiece.correctX;
    draggedPiece.y = draggedPiece.correctY;
    draggedPiece.isPlaced = true;
  }

  draggedPiece = null;
  draw();
});

</script>

</body>
</html>
